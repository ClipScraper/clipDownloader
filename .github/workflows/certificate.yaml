name: Apple certificate quick check (PR-only)

on:
  push:
    branches-ignore:
      - master
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: apple-cert-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  cert_check:
    # Run only on PR branch pushes when the latest commit message contains this flag
    if: ${{ contains(github.event.head_commit.message, '[apple-cert-check]') }}
    runs-on: macos-14

    env:
      # Secrets used by steps
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      # Precomputed booleans (become "true"/"false" strings)
      HAS_P8: ${{ secrets.APPLE_API_KEY_P8 != '' }}
      HAS_NOTARY_CREDS: ${{ secrets.APPLE_API_KEY != '' && secrets.APPLE_API_ISSUER != '' && secrets.APPLE_API_KEY_P8 != '' }}

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Import Developer ID certificate
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}               # base64 of .p12 (must include private key)
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euxo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

          # Sanity checks
          [[ -n "${APPLE_CERTIFICATE:-}" ]] || { echo "Missing APPLE_CERTIFICATE"; exit 1; }
          [[ -n "${APPLE_CERTIFICATE_PASSWORD:-}" ]] || { echo "Missing APPLE_CERTIFICATE_PASSWORD"; exit 1; }
          [[ -n "${KEYCHAIN_PASSWORD:-}" ]] || { echo "Missing KEYCHAIN_PASSWORD"; exit 1; }

          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          # Trust only tools we need for key access; DO NOT reference /usr/bin/notarytool (path varies & not required)
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcrun

          # Best-effort: allow Apple tools access to the private key
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true

          echo "== identities =="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

          CERT_SUBJ=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep "Developer ID Application" | head -n1 | awk -F\" '{print $2}')
          if [[ -z "$CERT_SUBJ" ]]; then
            echo "ERROR: No 'Developer ID Application' identity found in the imported .p12"; exit 1
          fi
          echo "APPLE_SIGNING_IDENTITY=$CERT_SUBJ" >> "$GITHUB_ENV"

      - name: Build and sign a tiny Mach-O (codesign smoke test)
        shell: bash
        run: |
          set -euxo pipefail
          cat > hello.c <<'EOF'
          #include <stdio.h>
          int main(){ puts("hello"); return 0; }
          EOF
          clang hello.c -o hello
          /usr/bin/codesign --force --options runtime --timestamp -s "$APPLE_SIGNING_IDENTITY" -v hello
          /usr/bin/codesign --verify --strict --verbose=4 hello

      - name: (Optional) Write App Store Connect API key
        if: ${{ env.HAS_P8 == 'true' }}
        shell: bash
        env:
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
        run: |
          set -euo pipefail
          printf "%s" "$APPLE_API_KEY_P8" > AuthKey.p8

      - name: (Optional) Notarize a minimal .app bundle end-to-end
        if: ${{ env.HAS_NOTARY_CREDS == 'true' }}
        shell: bash
        env:
          APPLE_API_KEY:    ${{ secrets.APPLE_API_KEY }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euxo pipefail
          mkdir -p CertCheck.app/Contents/MacOS
          cat > CertCheck.app/Contents/Info.plist <<'PLIST'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>CFBundleIdentifier</key><string>dev.hjoncour.certcheck</string>
            <key>CFBundleName</key><string>CertCheck</string>
            <key>CFBundleVersion</key><string>1</string>
            <key>CFBundleShortVersionString</key><string>1.0.0</string>
            <key>CFBundlePackageType</key><string>APPL</string>
            <key>CFBundleExecutable</key><string>hello</string>
          </dict></plist>
          PLIST
          cp hello CertCheck.app/Contents/MacOS/hello
          chmod +x CertCheck.app/Contents/MacOS/hello

          /usr/bin/codesign --force --options runtime --timestamp -s "$APPLE_SIGNING_IDENTITY" -v CertCheck.app
          /usr/bin/codesign --verify --deep --strict --verbose=4 CertCheck.app

          /usr/bin/ditto -c -k --sequesterRsrc --keepParent CertCheck.app CertCheck.zip

          # Use xcrun so we don't rely on a fixed path for notarytool
          xcrun notarytool authenticate --key ./AuthKey.p8 --key-id "$APPLE_API_KEY" --issuer "$APPLE_API_ISSUER" --validate
          xcrun notarytool submit CertCheck.zip --key ./AuthKey.p8 --key-id "$APPLE_API_KEY" --issuer "$APPLE_API_ISSUER" --wait --output-format json | tee notary-result.json
          xcrun stapler staple -v CertCheck.app

      - name: Upload preflight artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apple-cert-preflight
          path: |
            hello
            CertCheck.app
            CertCheck.zip
            notary-result.json
          if-no-files-found: ignore
          retention-days: 3

      - name: Cleanup keychain
        if: always()
        shell: bash
        run: |
          security delete-keychain "$KEYCHAIN_PATH" || true
