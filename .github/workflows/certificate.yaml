name: Apple certificate quick check (PR-only)

on:
  push:
    branches-ignore:
      - master
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: apple-cert-check-${{ github.ref }}
  cancel-in-progress: true

jobs:
  cert_check:
    # Run only on PR branch pushes when the latest commit message contains this flag
    if: ${{ contains(github.event.head_commit.message, '[apple-cert-check]') }}
    runs-on: macos-14

    env:
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      HAS_P8: ${{ secrets.APPLE_API_KEY_P8 != '' }}
      HAS_NOTARY_CREDS: ${{ secrets.APPLE_API_KEY != '' && secrets.APPLE_API_ISSUER != '' && secrets.APPLE_API_KEY_P8 != '' }}

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Import Developer ID certificate
        shell: bash
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}               # base64 of .p12 (with private key)
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          set -euxo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"

          [[ -n "${APPLE_CERTIFICATE:-}" ]] || { echo "Missing APPLE_CERTIFICATE"; exit 1; }
          [[ -n "${APPLE_CERTIFICATE_PASSWORD:-}" ]] || { echo "Missing APPLE_CERTIFICATE_PASSWORD"; exit 1; }
          [[ -n "${KEYCHAIN_PASSWORD:-}" ]] || { echo "Missing KEYCHAIN_PASSWORD"; exit 1; }

          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"

          # Import and allow required tools access (no hard-coded notarytool path)
          security import certificate.p12 -k "$KEYCHAIN_PATH" -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcrun

          # Best-effort: give Apple tools access to the key
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true

          echo "== identities (codesigning) =="
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

          # Accept both "Developer ID Application" and "Mac Developer ID Application" label variants
          CERT_APP=$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" \
            | awk -F\" '/(Developer ID Application|Mac Developer ID Application)/{print $2; exit}')

          if [[ -z "$CERT_APP" ]]; then
            echo "::error::You imported a 'Developer ID Installer' certificate. For app signing, you must export 'Developer ID Application: <Your Name> (TEAMID)' as a .p12 (with private key) from Keychain Access â†’ My Certificates, then update APPLE_CERTIFICATE/APPLE_CERTIFICATE_PASSWORD."
            security find-certificate -a -c "Developer ID Installer" "$KEYCHAIN_PATH" || true
            exit 1
          fi

          echo "APPLE_SIGNING_IDENTITY=$CERT_APP" >> "$GITHUB_ENV"
          echo "Using signing identity: $CERT_APP"

      - name: Build and sign a tiny Mach-O (codesign smoke test)
        shell: bash
        run: |
          set -euxo pipefail
          cat > hello.c <<'EOF'
          #include <stdio.h>
          int main(){ puts("hello"); return 0; }
          EOF
          clang hello.c -o hello
          /usr/bin/codesign --force --options runtime --timestamp -s "$APPLE_SIGNING_IDENTITY" -v hello
          /usr/bin/codesign --verify --strict --verbose=4 hello

      - name: (Optional) Write App Store Connect API key
        if: ${{ env.HAS_P8 == 'true' }}
        shell: bash
        env:
          APPLE_API_KEY_P8: ${{ secrets.APPLE_API_KEY_P8 }}
        run: |
          set -euo pipefail
          printf "%s" "$APPLE_API_KEY_P8" > AuthKey.p8

      - name: (Optional) Notarize a minimal .app bundle end-to-end
        if: ${{ env.HAS_NOTARY_CREDS == 'true' }}
        shell: bash
        env:
          APPLE_API_KEY:    ${{ secrets.APPLE_API_KEY }}
          APPLE_API_ISSUER: ${{ secrets.APPLE_API_ISSUER }}
        run: |
          set -euxo pipefail
          mkdir -p CertCheck.app/Contents/MacOS
          cat > CertCheck.app/Contents/Info.plist <<'PLIST'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0"><dict>
            <key>CFBundleIdentifier</key><string>dev.hjoncour.certcheck</string>
            <key>CFBundleName</key><string>CertCheck</string>
            <key>CFBundleVersion</key><string>1</string>
            <key>CFBundleShortVersionString</key><string>1.0.0</string>
            <key>CFBundlePackageType</key><string>APPL</string>
            <key>CFBundleExecutable</key><string>hello</string>
          </dict></plist>
          PLIST
          cp hello CertCheck.app/Contents/MacOS/hello
          chmod +x CertCheck.app/Contents/MacOS/hello

          /usr/bin/codesign --force --options runtime --timestamp -s "$APPLE_SIGNING_IDENTITY" -v CertCheck.app
          /usr/bin/codesign --verify --deep --strict --verbose=4 CertCheck.app

          /usr/bin/ditto -c -k --sequesterRsrc --keepParent CertCheck.app CertCheck.zip

          # Submit for notarization with key-based credentials and wait for result
          xcrun notarytool submit CertCheck.zip \
            --key ./AuthKey.p8 --key-id "$APPLE_API_KEY" --issuer "$APPLE_API_ISSUER" \
            --wait --output-format json | tee notary-result.json

          # Staple the ticket
          xcrun stapler staple -v CertCheck.app

      - name: Upload preflight artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: apple-cert-preflight
          path: |
            hello
            CertCheck.app
            CertCheck.zip
            notary-result.json
          if-no-files-found: ignore
          retention-days: 3

      - name: Cleanup keychain
        if: always()
        shell: bash
        run: |
          security delete-keychain "$KEYCHAIN_PATH" || true
